---
title: "Protein Categories"
subtitle: ""
author: "[Benjamin Dubreuil](https://github.com/benjamin-elusers/)"
home: "https://github.com/benjamin-elusers/yeastomics/"
github: "benjamin-elusers"
mail: "benjamin.dubreuil@weizmann.ac.il"
date: "`r format(Sys.time(), 'Last Modified: %d-%b-%Y %R %p')`"
output:
  rmdformats::downcute:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: tango
#  html_document: 
    code_download: true
    code_folding: hide
    fig_caption: yes
    keep_md: yes
#    toc: yes
    toc_depth: 3
    toc_float:
      toc_collapsed: true
    number_sections: true
    theme: lumen
  editor_options: 
    chunk_output_type: console
  bibliography: bibliography.bib
  csl: biomed-central.csl
---
<!-- Github Logo -->
<a href="https://github.com/benjamin-elusers/yeastomics/" class="github-corner" aria-label="View source on Github">
  <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#69b3a2; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
  </svg>
</a>

<style> 
.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}
@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}
@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      collapse = TRUE,
                      cache.lazy = FALSE,
                      autodep = TRUE,
                      warning = FALSE)

suppressPackageStartupMessages({
  source("src/utils.r")
  source("src/function_annotation.r")
  source("src/function_sequence.r")
  source("src/function_phylogenetic.r")
  source("src/function_analysis.r")
  source("src/function_datalocal.r")
  source("src/function_datapub.r")
  library(tictoc)
  library(tidyverse)
  q25 = function(x){ quantile(x,0.25) }
  q75 = function(x){ quantile(x,0.75) }
  d10 = function(x){ quantile(x,0.1) }
  d40 = function(x){ quantile(x,0.4) }
  d60 = function(x){ quantile(x,0.6) }
  d90 = function(x){ quantile(x,0.9) }
  get.d10  = function(x,...){ dplyr::slice_min(x,prop=0.1,with_ties = T,...) }
  get.d90  = function(x,...){ dplyr::slice_max(x,prop=0.1,with_ties = T,...) }
  get.q25  = function(x,...){ dplyr::slice_min(x,prop=0.25,with_ties = T,...) }
  get.q75  = function(x,...){ dplyr::slice_max(x,prop=0.25,with_ties = T,...) }
  get.iqr  = function(.data,x,lower,upper,...){ 
    col <- enquo(x)
    dplyr::filter(.data,between(!!col,quantile(!!col,lower),quantile(!!col,upper)))
  }
})

# turn off annoying messages from dplyr::summarise
options(dplyr.summarise.inform = FALSE)
```

# Introduction to "yeast-omics"

Yeast is a model unicellular organism belonging to the fungi kingdom,
within the eukaryotes ("true nucleus") domain of life.
The yeast genome of 12Mbp seems tiny when compared to higher eukaryotes,
which is at least one order of magnitude more compact in size.
Nonetheless, the yeast proteome contains ~6000 protein-coding genes,
making it only 3 to 4 times smaller than eukaryotes.
Strictly quantitatively, the yeast genome/proteome would be comparable to
the largest bacteria, similar to those of E.coli (4.5Mbp/4300) or B.subtilis (4.3Mbp/4800).

The yeast cellular volume is estimated around 50um^3 for haploid cells 
which is occupied at 80% by the cellular proteome (42 Millions of expressed macromolecules).
The cell interior is incredibly crowded with a protein density
of around 3-4 millions of molecules per femtoliter.
Despite the crowdedness, proteins are freely diffusing within the cell 
at an admirably fast pace of around 0.2us from one extremity to another.

Yet, the dynamic arrangements between millions of macromolecules within the cell is not trivial.

# Proteome evolution 

The approach to understand the organization of the yeast proteome consist in
searching for factors influencing the evolution of proteins. 

As previously reported, protein abundance holds a particularly important role in
driving molecular evolution of protein, explaining up to 50% of the variability
in conservation rate among proteins. 

The general trend is that highly expressed proteins are the most conserved
following the chemical law of mass action.

The association of protein expression with sequence conservation was found to be
supported by several underlying mechanisms, yet their degree of complementarity
is still a matter of active debate. 

How abundance really affects protein evolution is likely to require multi-causal explanations which we will not expand here. 
(e.g. translation cost, protein/mRNA stability and degradation, misinteractions ...) 

Nonetheless, protein abundance cannot fully account for the conservation of all 
residues in proteins. Even worse, the effect of abundance is likely to be 
involved in many biological processes, creating a potentially strong confounding
factor that may bias most evolutionary comparison between proteins.

Here, we explore a number of quantitative and qualitative variables
(referred as features and properties) derived from proteins, in order to unveil
the dark side of proteome evolution. 

However, we investigated how residual differences of protein conservation can be
explained by those features and properties after controlling for abundance.
Finally, we analyzed it within different protein categories which correspond to 
lists of related properties and features  (Sequence, Biophysics, Phenotypes...).

# Definitions

A protein feature is a measurable quantity related to its activity, composition...
The numerical values will be stored in a vector as a column of proteome data table. 
(e.g. disorder content, sequence length)

A protein property is a shared non-quantitative trait among a subset of proteins.
A vector named after the common characteristic will store the identifiers (ORF, UNIPROT...) of the subset members. (e.g. localization, pathway, function...)

Finally, a protein category correspond to a list of features or properties (Sequence, Biophysics, Phenotypes...)
Quantitative variables will be aggregated in one Proteome table (rows=proteins, columns=variables)

## Reference proteome sequence

SGD and Uniprot are the most reliable database gathering information about genes and proteins sequences.
SGD is the main provider for the assembled genome of S. cerevisiae as well as annotations about the genes.
Uniprot is a primary resource for protein information aggregating data from multiple specialized databases (structure, interactions, evolution, expression ...)


```{r reference}
# REFERENCE PROTEIN DATABASE ---------------------------------------------------
# Saccharomyces genome database (SGD) ------------------------------------------
SGD  = load.sgd.features(by.chr=T) %>% 
       mutate(chr.f = factor(chr, levels=unique(chr), # Add chromosome as a letter or symbol
                             labels = paste0("chr_",c(NA,LETTERS[1:2],"2-mu",LETTERS[3:16],"mito"))))

# Universal protein resource (UNIPROT) -----------------------------------------
file.uniprot.feature="data/uniprot-features.rds"
UNI = preload(file.uniprot.feature,loading.call = load.uniprot.features(),"Load uniprot features")

# REFERENCE PROTEOME SEQUENCES -------------------------------------------------
S288C  = load.sgd.proteome(withORF=T)
CDS    = load.sgd.CDS(withORF = T)
UNI.SC = load.uniprot.proteome('yeast')

UNIPROT = UNI %>%
          group_by(UNIPROTKB) %>%
          mutate( is_uniref = UNIPROTKB %in% names(UNI.SC), one2one = (n()==1) ) %>% 
          left_join(SGD %>% dplyr::select(sgdid,name,qual,gname,chr), by = c("SGD" = 'sgdid')) %>%
          dplyr::rename(ORF = name, GNAME=gname, CHR=chr)

# CROSS-REFERENCE PROTEOME -----------------------------------------------------
PROTEOME = UNIPROT %>% dplyr::select(UNIPROTKB, SGD, ORF, GNAME, PNAME)
```

## Genomic category
```{r genomic}
GENOMIC=list()
### QUANTITATIVE FEATURES
#### Proteins length -----------------------------------------------------------
df.len = tibble(orf=names(S288C),len=width(S288C))
# %GC content in genes ---------------------------------------------------------
df.gc  = tibble(orf=names(CDS),pGC = rowSums(letterFrequency(CDS, letters="CG",as.prob = T)))

### PROPERTIES (QUALITATIVE OR SEMI-QUANTITATIVE)
#### Chromosome Number ---------------------------------------------------------
CHR = SGD %>%
      filter(type=="ORF") %>%
      group_by(chr.f) %>% 
      dplyr::select(name)
chr.orf =  split(CHR$name,CHR$chr.f,drop=T)
#### range of protein length ---------------------------------------------------
GENOMIC$shortest = df.len %>% get.d10(order_by = len) %>% pull(orf)
GENOMIC$shorter  = df.len %>% get.q25(order_by = len) %>% pull(orf)
GENOMIC$average  = df.len %>% get.iqr(x=len,lo=0.4,up=0.6) %>% pull(orf)
GENOMIC$longest  = df.len %>% get.q75(order_by = len) %>% pull(orf)
GENOMIC$longest  = df.len %>% get.d90(order_by = len) %>% pull(orf)
#### range of GC content -------------------------------------------------------
GENOMIC$GC_lower  = df.gc %>% get.d10(order_by=pGC) %>% pull(orf)
GENOMIC$GC_low    = df.gc %>% get.q25(order_by=pGC) %>%  pull(orf)
GENOMIC$GC_mid    = df.gc %>% get.iqr(x=pGC,lo=0.4,up=0.6) %>% pull(orf)
GENOMIC$GC_high   = df.gc %>% get.q75(order_by=pGC) %>% pull(orf)
GENOMIC$GC_higher = df.gc %>% get.d90(order_by=pGC) %>% pull(orf)
#### Intron containing genes ---------------------------------------------------
GENOMIC$has_intron = SGD %>% filter(type=='intron') %>% pull(parent) %>% intersect(y=names(S288C))
#### Chromosome genes ----------------------------------------------------------
GENOMIC = append(GENOMIC,chr.orf)
```

## Biophysical category
```{r biophysical}
BIOPHYSICS=list()

### QUANTITATIVE FEATURES
#### Single amino-acid frequencies ------------------------------------------------
aa.freq = letterFrequency(UNI.SC,as.prob = T,letters = get.AA1())
df.aa = aa.freq %>% as_tibble %>% mutate(uni=names(UNI.SC)) %>% relocate(uni)

#### Grouped amino-acid frequencies -----------------------------------------------
aaprop = seqinr::SEQINR.UTIL$AA.PROPERTY
aaenrich = function(BS,alphabet){ 
  alphabet.freq = rowSums(letterFrequency(BS,as.prob = T,letters = alphabet))
  prot.enrich = tibble(id=names(BS),fr=alphabet.freq)
}
aaset = paste0(names(aaprop), "_", map(aaprop,str_c,collapse=''))
df.aa_class = map(aaprop, aaenrich, BS=UNI.SC ) %>% 
  purrr::reduce(full_join,by='id') %>%
  rename_with(~aaset, starts_with("fr"))

# Disorder content (segment, fraction, total) ----------------------------------

D2P2 = get.d2p2.diso(load.d2p2(saved = "data/d2p2-yeast-uniprotKB.rds"),as.df = T) %>%
       mutate(d2p2_seg = find.consecutive(d2p2_diso>=7, TRUE, min=3),
              d2p2_gap = find.consecutive(d2p2_diso>=7, FALSE, min=1)) %>%
       group_by(d2p2_seg) %>% mutate( d2p2_seglen = sum_(d2p2_seg!=0)) %>%
       group_by(d2p2_gap) %>% mutate( d2p2_gaplen = sum_(d2p2_gap!=0)) %>%
       group_by(d2p2_id, d2p2_size, has_d2p2) %>% 
       summarise(L.d2p2 = sum_(d2p2_diso>=7), 
                 f.d2p2 = mean_(d2p2_diso>=7),
                 n.seg = n_distinct(d2p2_seg),
                 L.segmax = max(d2p2_seglen))
  
DUB = load.dubreuil2019.data(3)
dub = load.dubreuil2019.data(1)
IUP = DUB %>% dplyr::select()


test = D2P2 %>% filter(d2p2_id == "P34111")
x = test$d2p2_diso>=7


### PROPERTIES (QUALITATIVE OR SEMI-QUANTITATIVE)
#### Protein domains (nodom,single,multi)  ----------------------------------------
SUPFAM = load.superfamily() %>% 
          dplyr::rename(seqid = "Sequence ID") %>%
          count(seqid,name="n_dom")
#           group_by(`Sequence ID`) %>% 
#           count(`Model ID`,name='n_uniq') %>%
table_(SUPFAM$n_dom)

BIOPHYSICS$supfam_none   = setdiff(PROTEOME$UNIPROTKB,SUPFAM$seqid)
BIOPHYSICS$supfam_single = SUPFAM %>% filter(n_dom==1) %>% pull(seqid)
BIOPHYSICS$supfam_pair   = SUPFAM %>% filter(n_dom==2) %>% pull(seqid)
BIOPHYSICS$supfam_multi  = SUPFAM %>% filter(n_dom>=3) %>% pull(seqid)

PFAM= load.pfam() %>% 
      count(seq_id,name="n_dom")
        #group_by(seq_id) %>%
        #count(hmm_acc,name='n_uniq') %>%
table_(PFAM$n_dom)

BIOPHYSICS$pfam_none   = setdiff(PROTEOME$UNIPROTKB,PFAM$seq_id)
BIOPHYSICS$pfam_single = PFAM %>% filter(n_dom==1) %>% pull(seq_id)
BIOPHYSICS$pfam_pair   = PFAM %>% filter(n_dom==2) %>% pull(seq_id)
BIOPHYSICS$pfam_multi  = PFAM %>% filter(n_dom>=3) %>% pull(seq_id)

#NDOM = DUB %>%
#        group_by(id) %>%
#        summarize( ndom = max(domain.seg) )
#table( DUB[DUB$id == "D6W196","superfamily_ids"] )

```

## Interactions category
```{r interactions}
INTERACTIONS=list()
library(network)
library(tidygraph)
library(ggraph)

###
#### PROTEIN-PROTEIN INTERACTIONS

##### INTACT network
#/media/elusers/users/hugo/07_3DComplex_scripts/scripts_PPIs_networks/stack_studies_PPIs_nored_PMID_28122020_INTACT.R
INTACT = read.csv("/media/elusers/users/hugo/07_3DComplex_scripts/PPIs_analysis/INTACT/PPIs_cerevisiae.txt",sep = "\t", quote = "", stringsAsFactors = F)
colnames(INTACT) = c("protA","protB","altA","altB","aliasA","aliasB","method","pub.author1","pub.id","taxA","taxB","typeAB","src.db","int.id","conf","expansion.method","bio.roleA","bio.roleB","exp.roleA","exp.roleB","typeA","typeB","xrefA","xrefB","xrefAB","annotA","annotB","annotAB","host","parAB","created","updated","checksumA","checksumB","checksumAB","negative","featA","featB","stoichioA","stoichioB","id.met.protA","id.met.protB")

# remove small molecules and non-protein 
cat("nb PPIs before rm EBI: ", nrow(INTACT), "\n")
INTACT.1 = INTACT[!(grepl("EBI", INTACT$protA) | grepl("EBI", INTACT$protB)),]
cat("nb PPIs after rm EBI: ", nrow(INTACT.1), "\n")

# remove duplicated interactions (with different Pubmed ID)
# 
# keep only protein interactions (uniprot/orf)
# filter for direct method
# return the matrix of interactions

#dplyr::select(-c(created,updated,checksumA,checksumB,checksumAB,taxA,taxB))

##### STRING network
STRING = load.STRING(tax="4932",phy=T, ful=T, min.score = 700) %>% 
             mutate(ORF1 = str_extract(protein1,SGD.nomenclature()),
                    ORF2 = str_extract(protein2,SGD.nomenclature())
             ) %>% relocate(ORF1,ORF2) %>% dplyr::select(-c(protein1,protein2))
 
STRING_net = as_tbl_graph(STRING)


#### COMPLEXES
mers= c('mono','di','tri','tetra','penta','hexa','septa','octa','nona','deca')
##### CYC = Catalogue of Yeast Complexes
CYC = load.pu.2008.data() %>% # BASED ON ORF
      mutate(oligomers = cut(n_members, breaks = c(1:10,20,81), 
                             labels =  c(mers[2:10],'high_oligomer','molecular_machine'))
            )
CYC_complexes = split(CYC$ORF,CYC$Complex)
CYC_oligomers = split(CYC$ORF,CYC$oligomers)
CYC_machines = keep(CYC_complexes,function(X){ length(X) > 9  })
INTERACTIONS=append(INTERACTIONS,CYC_machines)
INTERACTIONS=append(INTERACTIONS,CYC_oligomers)

##### COMPLEXTAB = Complex Portal from EBI
CPX = load.meldal.2019.data() %>%
  filter(is_uniprot) %>% # BASED ON UNIPROT
      mutate(oligomers = cut(n_members, breaks = c(1:10,20,81), 
                             labels = c(mers[2:10],'high_oligomer','molecular_machine'))
            )
EBI_complexes = split(CPX$members,CPX$CPLX_NAME)
EBI_oligomers = split(CPX$members,CPX$oligomers)
EBI_machines = keep(EBI_complexes,function(X){ length(X) > 9  })
INTERACTIONS=append(INTERACTIONS,EBI_machines)
INTERACTIONS=append(INTERACTIONS,EBI_oligomers)
```


## Functions category
```{r function}
FUNCTIONS=list()

# GO Biological Processes and Molecular Functions
UNIGO = get.uniprot.go(UNIPROT$UNIPROTKB) %>%  # Uniprot-based GO annotation
        mutate( go = paste0(ONTOLOGY,"_",goterm)) %>% 
        arrange(go) 
unigo  = UNIGO %>% # get goterm from BP and MF not obsolete and with 30-1000 proteins annotated
         filter(!obsolete & between(shared,30,1000) & ONTOLOGY != "CC")
# Convert to a matrix format (columns = GO term, rows=proteome)
unigo.m  = unigo %>%  mutate(seen=1) %>%
           pivot_wider( id_cols = c('UNIPROT'), names_from = 'go', values_from = 'seen', 
                        values_fn=list(seen = sum),values_fill = list(seen=0))
M = cor(unigo.m[,-1], use = 'pairwise',method = 'spearman') # similarity between go term
ol =  crossprod(unigo.m[,-1] %>% as.matrix)
ol_scaled = ( ol + abs(min(ol)) )  / max(ol + abs(min(ol)))
pheatmap::pheatmap(M,show_colnames = F,show_rownames = T,cluster_cols = T,cluster_rows = T, fontsize = 4)
                   #filename = "plots/GO_profile_spearman.pdf", height = 18, width=10)
pheatmap::pheatmap(ol_scaled,show_colnames = F,show_rownames = T,cluster_cols =T,cluster_rows = T, fontsize = 4)
                   #filename = "plots/GO_profile_overlap.pdf", height = 18, width=10)
go =  split(unigo$UNIPROT,unigo$go)
FUNCTIONS = append(FUNCTIONS,go)

# Classification of Biological functions

load.vanleeuwen2016.data()


```

## Phenotypes category
```{r phenotype}
PHENOTYPES=list()

#### essentiality
ESS = load.vanleeuwen2020.data()
essential = ESS %>% 
                filter(disp !='Dispensable') %>% 
                filter(disp == 'Core' | (KO_exp =='Indispensable' & disp_score < 0.4 )) %>%
                pull(ORF)
#### Dispensability
dispensable = ESS %>% filter(disp =='Dispensable' ) %>% pull(ORF)
PHENOTYPES$essential   = essential
PHENOTYPES$dispensable = dispensable

#### chemogenomics profile
#CHM = load.lee2014.data() # Chemogenomic fitness signatures
# MDR -> multi-drug resistance (>20% fitness)


#### Subcellular localization category

UNILOC = get.uniprot.localization(annot=UNIPROT,loc_to_columns = T)
uniloc = get.uniprot.localization(annot=UNIPROT,loc_to_columns = F)
THR.LOC.SIZE = 50 # MINIMUM NUMBER OF PROTEINS PER COMPARTMENT 
LOC.size = sort(colSums(UNILOC[,-c(1:3)]))
LOC50 = sort( names( LOC.size[LOC.size>THR.LOC.SIZE] ) )
PHENOTYPES$has_foci = UNILOC %>% filter(HAS_FOCI) %>% pull(id)
PHENOTYPES$has_iso  = UNILOC %>% filter(HAS_ISOFORM) %>% pull(id)
#
loc = split(uniloc$id,uniloc$loc) 
subloc = keep(loc,function(X){ length(X)>30 })
PHENOTYPES=append(PHENOTYPES,subloc)

multiloc = UNILOC %>% 
            group_by(id) %>% 
            mutate( nloc = sum(c_across(!starts_with("HAS_TO"))),
                    nloc50 = sum(c_across(LOC50)),
                    localized = paste(sort(uniloc$loc[ uniloc$id == id ]), collapse = "#"),
                    localized50 = paste(intersect(LOC50,sort(uniloc$loc[ uniloc$id == id ])), collapse = "#")) %>%
            filter(nloc50>3) %>% arrange(nloc50,nloc) %>%
            dplyr::select('id','HAS_FOCI','HAS_ISOFORM','nloc','nloc50','localized50')
  
head(multiloc)


```


# Output 
```{r categories-table}
# Make categories table with:

CATEGORIES = list(GENOMIC,BIOPHYSICS,INTERACTIONS,FUNCTIONS,PHENOTYPES) 

length(CATEGORIES)
lapply(CATEGORIES,length)

# CODON ADATAPTION
df.tai=load.codon.usage(inputseq=load.sgd.CDS())
# DUPLICATED GENES
YGOB=load.ygob.ohnologs() %>%  group_by(orf, dup.orf, pid, rlen)
OHNO = get.sc.ohno() %>%
       left_join(S2U %>% rename_all(list(~xxS(x=.,sx='ref'))), by=c('orf'='ORF.ref')) %>%
       left_join(S2U %>% rename_all(list(~xxS(x=.,sx='dup'))), by=c('dup.orf'='ORF.dup'))
head(ohno)
STAB = load.leunenberger2017.data() %>%
  add_count(Protein_ID,name='npep') %>%
  dplyr::select(Protein_ID,Tm.Protein,Protinfo,Protein.Coverage,Length,
                Measured.Domains, Theoretical.Number.of.Domain,Essential,npep ) %>%
  distinct() %>%
  mutate( nres = round(0.01*Protein.Coverage*Length))


```