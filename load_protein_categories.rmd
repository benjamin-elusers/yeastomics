---
title: "Protein Categories"
author: "Benjamin Dubreuil"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("src/utils.r")
source("src/function_annotation.r")
source("src/function_sequence.r")
source("src/function_phylogenetic.r")
source("src/function_analysis.r")
source("src/function_datalocal.r")
source("src/function_datapub.r")
library(tictoc)
library(tidyverse)
d10  = function(x,...){ slice_min(x,prop=0.1,with_ties = T,...) }
d90  = function(x,...){ slice_max(x,prop=0.1,with_ties = T,...) }
q25  = function(x,...){ slice_min(x,prop=0.25,with_ties = T,...) }
q75  = function(x,...){ slice_max(x,prop=0.75,with_ties = T,...) }

semi.quantitative = function(df){}

```

# Introduction to "yeast-omics"

Yeast is a model unicellular organism belonging to the fungi kingdom,
within the eukaryotes ("true nucleus") domain of life.
The yeast genome of 12Mbp seems tiny when compared to higher eukaryotes,
which is at least one order of magnitude more compact in size.
Nonetheless, the yeast proteome contains ~6000 protein-coding genes,
making it only 3 to 4 times smaller than eukaryotes.
Strictly quantitatively, the yeast genome/proteome would be comparable to
the largest bacteria, similar to those of E.coli (4.5Mbp/4300) or B.subtilis (4.3Mbp/4800).

The yeast cellular volume is estimated around 50um^3 for haploid cells 
which is occupied at 80% by the cellular proteome (42 Millions of expressed macromolecules).
The cell interior is incredibly crowded with a protein density
of around 3-4 millions of molecules per femtoliter.
Despite the crowdedness, proteins are freely diffusing within the cell 
at an admirably fast pace of around 0.2us from one extremity to another.

Yet, the dynamic arrangements between millions of macromolecules within the cell is not trivial.

# Proteome evolution 

The approach to understand the organization of the yeast proteome consist in
searching for factors influencing the evolution of proteins. 

As previously reported, protein abundance holds a particularly important role in
driving molecular evolution of protein, explaining up to 50% of the variability
in conservation rate among proteins. 

The general trend is that highly expressed proteins are the most conserved
following the chemical law of mass action.

The association of protein expression with sequence conservation was found to be
supported by several underlying mechanisms, yet their degree of complementarity
is still a matter of active debate. 

How abundance really affects protein evolution is likely to require multi-causal explanations which we will not expand here. 
(e.g. translation cost, protein/mRNA stability and degradation, misinteractions ...) 

Nonetheless, protein abundance cannot fully account for the conservation of all 
residues in proteins. Even worse, the effect of abundance is likely to be 
involved in many biological processes, creating a potentially strong confounding
factor that may bias most evolutionary comparison between proteins.

Here, we explore a number of quantitative and qualitative variables
(referred as features and properties) derived from proteins, in order to unveil
the dark side of proteome evolution. 

However, we investigated how residual differences of protein conservation can be
explained by those features and properties after controlling for abundance.
Finally, we analyzed it within different protein categories which correspond to 
lists of related properties and features  (Sequence, Biophysics, Phenotypes...).

# Definitions

A protein feature is a measurable quantity related to its activity, composition...
The numerical values will be stored in a vector as a column of proteome data table. 
(e.g. disorder content, sequence length)

A protein property is a shared non-quantitative trait among a subset of proteins.
A vector named after the common characteristic will store the identifiers (ORF, UNIPROT...) of the subset members. (e.g. localization, pathway, function...)

Finally, a protein category correspond to a list of features or properties (Sequence, Biophysics, Phenotypes...)
Quantitative variables will be aggregated in one Proteome table (rows=proteins, columns=variables)

## Reference proteome sequence

SGD and Uniprot are the most reliable database gathering information about genes and proteins sequences.
SGD is the main provider for the assembled genome of S. cerevisiae as well as annotations about the genes.
Uniprot is a primary resource for protein information aggregating data from multiple specialized databases (structure, interactions, evolution, expression ...)


```{r reference}
# REFERENCE PROTEIN DATABASE ---------------------------------------------------
# Saccharomyces genome database (SGD) ------------------------------------------
SGD  = load.sgd.features(by.chr=T) %>% 
       mutate(chr.f = factor(chr, 
                               levels=unique(chr),
                               labels = paste0("chr_",c(NA,LETTERS[1:2],"2-mu",LETTERS[3:16],"mito"))))

       
# Universal protein resource (UNIPROT) -----------------------------------------
file.uniprot.feature="data/uniprot-features.rds"
UNI = preload(file.uniprot.feature,loading.call = load.uniprot.features(),"Load uniprot features")

# REFERENCE PROTEOME SEQUENCES -------------------------------------------------
S288C  = load.sgd.proteome(withORF=T)
CDS    = load.sgd.CDS(withORF = T)
UNI.SC = load.uniprot.proteome('yeast')

UNIPROT = UNI %>%
          group_by(UNIPROTKB) %>%
          mutate( is_uniref = UNIPROTKB %in% names(UNI.SC), one2one = (n()==1) ) %>% 
          left_join(SGD %>% dplyr::select(sgdid,name,qual,gname,chr), by = c("SGD" = 'sgdid')) %>%
          dplyr::rename(ORF = name, GNAME=gname, CHR=chr)

# CROSS-REFERENCE PROTEOME -----------------------------------------------------
PROTEOME = UNIPROT %>% dplyr::select(UNIPROTKB, SGD, ORF, GNAME, PNAME)
```

## Genomic category
```{r genomic}
GENOMIC=list()
### QUANTITATIVE FEATURES
#### Proteins length --------------------------------------------------------------
df.len = tibble(orf=names(S288C),len=width(S288C))
# %GC content in genes ---------------------------------------------------------
df.gc  = tibble(orf=names(CDS),pGC = rowSums(letterFrequency(CDS, letters="CG",as.prob = T)))


### PROPERTIES (QUALITATIVE OR SEMI-QUANTITATIVE)
#### Chromosome Number ------------------------------------------------------------
CHR = SGD %>%
      filter(type=="ORF") %>%
      group_by(chr.f) %>% 
      dplyr::select(name)
chr.orf =  split(CHR$name,CHR$chr.f,drop=T)
#### range of protein length ------------------------------------------------------
GENOMIC$shortest = df.len %>% d10(order_by = len) %>% pull(orf)
GENOMIC$shorter  = df.len %>% q25(order_by = len) %>% pull(orf)
GENOMIC$average  = df.len %>% filter(between(len,Qlen['25%'],Qlen['75%'])) %>% pull(orf)
GENOMIC$longest  = df.len %>% q75(order_by = len) %>% pull(orf)
GENOMIC$longest  = df.len %>% d90(order_by = len) %>% pull(orf)
#### range of GC content ----------------------------------------------------------
GENOMIC$GC_lower  = df.gc %>% d10(order_by=pGC) %>% pull(orf)
GENOMIC$GC_low    = df.gc %>% q25(order_by=pGC) %>%  pull(orf)
GENOMIC$GC_mid    = df.gc %>% filter(between(pGC,QGC['25%'],QGC['75%'])) %>% pull(orf)
GENOMIC$GC_high   = df.gc %>% q75(order_by=pGC) %>% pull(orf)
GENOMIC$GC_higher = df.gc %>% d90(order_by=pGC) %>% pull(orf)
#### Intron containing genes ------------------------------------------------------
GENOMIC$has_intron = SGD %>% filter(type=='intron') %>% pull(parent) %>% intersect(y=names(S288C))
#### Chromosome genes -------------------------------------------------------------
GENOMIC = append(GENOMIC,chr.orf)
```

## Biophysical category
```{r biophysical}
BIOPHYSICS=list()

### QUANTITATIVE FEATURES
#### Single amino-acid frequencies ------------------------------------------------
aa.freq = letterFrequency(UNI.SC,as.prob = T,letters = get.AA1())
df.aa = aa.freq %>% as_tibble %>% mutate(uni=names(UNI.SC)) %>% relocate(uni)

#### Grouped amino-acid frequencies -----------------------------------------------
aaprop = seqinr::SEQINR.UTIL$AA.PROPERTY
aaenrich = function(BS,alphabet){ 
  alphabet.freq = rowSums(letterFrequency(BS,as.prob = T,letters = alphabet))
  prot.enrich = tibble(id=names(BS),fr=alphabet.freq)
}
aaset = paste0(names(aaprop), "_", map(aaprop,str_c,collapse=''))
df.aa_class = map(aaprop, aaenrich, BS=UNI.SC ) %>% 
  purrr::reduce(full_join,by='id') %>%
  rename_with(~aaset, starts_with("fr"))
# Disorder content (segment, fraction, total) ----------------------------------

### PROPERTIES (QUALITATIVE OR SEMI-QUANTITATIVE)
#### Protein domains (nodom,single,multi)  ----------------------------------------
SUPFAM = load.superfamily() %>% count(`Sequence ID`,name="n_dom")
#           group_by(`Sequence ID`) %>% 
#           count(`Model ID`,name='n_uniq') %>%
table_(SUPFAM$n_dom)

PFAM= load.pfam() %>% count(seq_id,name="n_dom")
table_(PFAM$n_dom)
        #group_by(seq_id) %>%
        #count(hmm_acc,name='n_uniq') %>%
#
DUB = load.dubreuil2019.data(3)
NDOM = DUB %>%
        group_by(id) %>%
        summarize( ndom = max(domain.seg) )
table( DUB[DUB$id == "D6W196","superfamily_ids"] )
names(GENOMIC)
sapply(GENOMIC,n_distinct)


```

## Interactions category
```{r interactions}
###
#### PROTEIN-PROTEIN INTERACTIONS
#/media/elusers/users/hugo/07_3DComplex_scripts/scripts_PPIs_networks/stack_studies_PPIs_nored_PMID_28122020_INTACT.R
PPI = read.csv("/media/elusers/users/hugo/07_3DComplex_scripts/PPIs_analysis/INTACT/PPIs_cerevisiae.txt",sep = "\t", quote = "", stringsAsFactors = F)
colnames(PPI) = c("protA","protB","altA","altB","aliasA","aliasB","method","pub.author1","pub.id","taxA","taxB","typeAB","src.db","int.id","conf","expansion.method","bio.roleA","bio.roleB","exp.roleA","exp.roleB","typeA","typeB","xrefA","xrefB","xrefAB","annotA","annotB","annotAB","host","parAB","created","updated","checksumA","checksumB","checksumAB","negative","featA","featB","stoichioA","stoichioB","id.met.protA","id.met.protB")
# remove duplicated interactions (with different Pubmed ID)
# 
# keep only protein interactions (uniprot/orf)
# filter for direct method
# return the matrix of interactions

dplyr::select(-c(created,updated,checksumA,checksumB,checksumAB,taxA,taxB))

#### COMPLEXES
CYC = load.pu.2008.data() # BASED ON ORF
CPX = load.meldal.2019.data() # BASED ON UNIPROT
test = CYC %>% filter(n_members > 5) %>% pivot_wider(names_from = Complex,values_from = c(ORF))
test[11:50,]
```

## Phenotypes category
```{r phenotype}
#### essentiality
ESS = load.vanleeuwen2020.data()
essential = ESS %>% 
                filter(disp !='Dispensable') %>% 
                filter(disp == 'Core' | (KO_exp =='Indispensable' & disp_score < 0.4 )) %>%
                pull(ORF)

#### Dispensability
dispensable = ESS %>% filter(disp =='Dispensable' ) %>% pull(ORF)

CAT$phenotype.essential =  CAT$ORF %in% essential
CAT$phenotype.dispensable =  CAT$ORF %in% dispensable

table(ESS$disp[ESS$ORF %in% CAT$dispensable])
table(ESS$disp[ESS$ORF %in% CAT$essential])

#### chemogenomics profile
CHM = load.lee2014.data() # Chemogenomic fitness signatures
# MDR -> multi-drug resistance (>20% fitness)

#
UNIGO = get.uniprot.go(UNIPROT$UNIPROTKB)
UNILOC = get.uniprot.localization(annot=UNIPROT,loc_to_columns = T)
uniloc = get.uniprot.localization(annot=UNIPROT,loc_to_columns = F)

#### solubility
has_foci = UNILOC %>% filter(HAS_FOCI) %>% pull(id)
has_iso  = UNILOC %>% filter(HAS_ISOFORM) %>% pull(id)

#### Subcellular localization category


THR.LOC.SIZE = 50 # MINIMUM NUMBER OF PROTEINS PER COMPARTMENT 
LOC.size = sort(colSums(UNILOC[,-c(1:3)]))
LOC50 = sort( names( LOC.size[LOC.size>THR.LOC.SIZE] ) )

CAT$loc.bud_neck = UNILOC %>% filter(bud_neck == 1) %>% pull(id)
CAT$loc.cell_membrane = UNILOC %>% filter(cell_membrane == 1) %>% pull(id)
CAT$loc.cell_wall = UNILOC %>% filter(cell_wall == 1) %>% pull(id)
CAT$loc.centromere = UNILOC %>% filter(centromere == 1) %>% pull(id)
CAT$loc.chromosome = UNILOC %>% filter(chromosome == 1) %>% pull(id)
CAT$loc.cytoplasm = UNILOC %>% filter(cytoplasm == 1) %>% pull(id)
CAT$loc.cytoplasmic_side = UNILOC %>% filter(cytoplasmic_side == 1) %>% pull(id)
CAT$loc.cytoskeleton = UNILOC %>% filter(cytoskeleton == 1) %>% pull(id)
CAT$loc.endoplasmic_reticulum_membrane = UNILOC %>% filter(endoplasmic_reticulum_membrane == 1) %>% pull(id)
CAT$loc.endosome_membrane = UNILOC %>% filter(endosome_membrane == 1) %>% pull(id)
CAT$loc.golgi_apparatus = UNILOC %>% filter(golgi_apparatus == 1) %>% pull(id)
CAT$loc.golgi_apparatus_membrane = UNILOC %>% filter(golgi_apparatus_membrane == 1) %>% pull(id)
CAT$loc.gpi.anchor = UNILOC %>% filter(gpi.anchor == 1) %>% pull(id)
CAT$loc.lipid.anchor = UNILOC %>% filter(lipid.anchor == 1) %>% pull(id)
CAT$loc.membrane = UNILOC %>% filter(membrane == 1) %>% pull(id)
CAT$loc.mitochondrion = UNILOC %>% filter(mitochondrion == 1) %>% pull(id)
CAT$loc.mitochondrion_inner_membrane = UNILOC %>% filter(mitochondrion_inner_membrane == 1) %>% pull(id)
CAT$loc.mitochondrion_intermembrane_space = UNILOC %>% filter(mitochondrion_intermembrane_space == 1) %>% pull(id)
CAT$loc.mitochondrion_matrix = UNILOC %>% filter(mitochondrion_matrix == 1) %>% pull(id)
CAT$loc.mitochondrion_membrane = UNILOC %>% filter(mitochondrion_membrane == 1) %>% pull(id)
CAT$loc.mitochondrion_outer_membrane = UNILOC %>% filter(mitochondrion_outer_membrane == 1) %>% pull(id)
CAT$loc.multi.pass_membrane_protein = UNILOC %>% filter(multi.pass_membrane_protein == 1) %>% pull(id)
CAT$loc.nucleolus = UNILOC %>% filter(nucleolus == 1) %>% pull(id)
CAT$loc.nucleus = UNILOC %>% filter(nucleus == 1) %>% pull(id)
CAT$loc.nucleus_membrane = UNILOC %>% filter(nucleus_membrane == 1) %>% pull(id)
CAT$loc.peripheral_membrane_protein = UNILOC %>% filter(peripheral_membrane_protein == 1) %>% pull(id)
CAT$loc.secreted = UNILOC %>% filter(secreted == 1) %>% pull(id)
CAT$loc.single.pass_membrane_protein = UNILOC %>% filter(single.pass_membrane_protein == 1) %>% pull(id)
CAT$loc.single.pass_type_ii_membrane_protein = UNILOC %>% filter(single.pass_type_ii_membrane_protein == 1) %>% pull(id)
CAT$loc.vacuole_membrane = UNILOC %>% filter(vacuole_membrane == 1) %>% pull(id)

multiloc = UNILOC %>% 
            group_by(id) %>% 
            mutate( nloc = sum(c_across(!starts_with("HAS_TO"))),
                    nloc50 = sum(c_across(LOC50)),
                    localized = paste(sort(uniloc$loc[ uniloc$id == id ]), collapse = "#"),
                    localized50 = paste(intersect(LOC50,sort(uniloc$loc[ uniloc$id == id ])), collapse = "#")) %>%
            filter(nloc50>3) %>% arrange(nloc50,nloc) %>%
            dplyr::select('id','HAS_FOCI','HAS_ISOFORM','nloc','nloc50','localized50')
  
head(multiloc)

```

```{python}


```

```{r categories-table}
# Make categories table with:

```