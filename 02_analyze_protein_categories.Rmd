---
title: "Analyze Protein Categories"
subtitle: ""
author: "[Benjamin Dubreuil](https://github.com/benjamin-elusers/)"
home: "https://github.com/benjamin-elusers/yeastomics/"
github: "benjamin-elusers"
mail: "benjamin.dubreuil@weizmann.ac.il"
date: "`r format(Sys.time(), 'Last Modified: %d-%b-%Y %R %p')`"
output:
  rmdformats::downcute:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: tango
#  html_document: 
    code_download: true
    code_folding: hide
    fig_caption: yes
    keep_md: yes
#    toc: yes
    toc_depth: 3
    toc_float:
      toc_collapsed: true
    number_sections: true
    theme: lumen
  editor_options: 
    chunk_output_type: console
  bibliography: bibliography.bib
  csl: biomed-central.csl
---
<!-- Github Logo -->
<a href="https://github.com/benjamin-elusers/yeastomics/" class="github-corner" aria-label="View source on Github">
  <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#69b3a2; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
  </svg>
</a>

<style> 
.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}
@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}
@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      collapse = TRUE,
                      cache.lazy = FALSE,
                      autodep = TRUE,
                      warning = FALSE)
if('utils' %in% search()){ detach('utils') }
utils = attach(NULL,name = 'utils')
if('funcs' %in% search()){ detach('funcs') }
funcs = attach(NULL,name = 'funcs')

suppressPackageStartupMessages({
  library(tictoc)
  library(tidyverse)
  library(stringr)
  library(hablar)
  
  
  source("src/utils.r")
  source("src/function_annotation.r")
  source("src/function_sequence.r")
  source("src/function_phylogenetic.r")
  source("src/function_analysis.r")
  source("src/function_datalocal.r")
  source("src/function_datapub.r")
})

# turn off annoying messages from dplyr::summarise
options(dplyr.summarise.inform = FALSE)
```

# Evolutionary dataset

```{r evodata}
# EVOLUTIONARY RATE
ER = load.dubreuil2021.data(1) %>% 
     as_tibble() %>%
     dplyr::select(c(starts_with('EVO.'),'PPM','ORF','UNIPROT')) %>%
     hablar::convert(dbl(EVO.FULL), dbl(PPM)) %>% 
     ungroup()
# Fitting mean Evolutionary rate (R) to Protein abundance (E)
init.params =  list(Asym = 3, xmid = 1.5, scal=-1)
nls.fit = nls(EVO.FULL ~ SSlogis(PPM,Asym,xmid,scal),start=init.params,data = ER )
fit.ER = broom::augment_columns(x = nls.fit, data = ER) %>% 
         mutate(SSR = sum(.resid^2), SR = sum(.resid) )

```

# Protein categories

## Loading precomputed data

```{r protcat}
# protein properties (qualitative)
PROP=readRDS(get.last.file("output","proteome-properties"))
PROP_lgl = PROP %>% 
            ungroup() %>% 
            dplyr::select( where(is.logical) )  %>% 
            convert(num(everything())) %>%
            as.matrix
# protein features (quantitative)
FEAT=readRDS(get.last.file("output","proteome-features"))
FEAT_num = FEAT %>%
            ungroup() %>% 
            dplyr::select( where(is.numeric) )

TOT_PROP=ncol(PROP_lgl)
TOT_FEAT=ncol(FEAT_num)
# ER FITTED PROPERTIES
ER.PROP = fit.ER %>% left_join(PROP,by=c('UNIPROT'='UNIPROTKB','ORF'='ORF'))
dim(ER.PROP)
ER.FEAT = fit.ER %>% left_join(FEAT,by=c('UNIPROT'='UNIPROTKB','ORF'='ORF'))
dim(ER.FEAT)
```


There are a total of **`r TOT_PROP`** proteome properties and **`r TOT_FEAT`**
We also gathered **`r TOTAL_FEATURES`** protein features.

## Compute properties similarities

To compare properties, we will use the Jaccard distance on the binary matrix where rows are proteins and columns are the properties. The distance corresponds to the proportion of (TRUE, TRUE) pairs, but not considering (FALSE, FALSE) pairs.

So it compares the intersection with the union of protein sets between properties.


```{r properties-similarity}
# Pearson correlation between properties
prop_cor = preload("output/properties-correlation.rds",
                   coop::pcor(PROP_lgl), 
                   doing="Computing Pearson correlation between properties...")
library(proxy)
# Example of Jaccard distance on binary data
# x <- matrix(sample(c(FALSE, TRUE), 50, rep = TRUE), ncol = 10)
# dist(x, x, method = "Jaccard") # cross distances

# jaccard distance between properties
prop_jacc = preload("output/properties-jaccard.rds", 
                   proxy::dist(PROP_lgl, PROP_lgl, by_rows=F, method="Jaccard"),
                   doing="Computing Jaccard distance between properties...") 
dim(prop_jacc)
hc = hclust(d=stats::as.dist(prop_jacc),method = 'ward.D2')
grp = cutree(hc,k=100) 


pheatmap::pheatmap(prop_jacc,
                   show_colnames = F, show_rownames = T,
                   cluster_cols = hc, cluster_rows = hc,
                   clustering_distance_rows = prop_jacc,
                   clustering_distance_cols = prop_jacc,
                   cutree_rows = 100,cutree_cols = 100,
                   fontsize=3, border_color = NA, silent=T, 
                   cellheight=3, cellwidth=3,
                   filename="output/properties-jaccard.pdf", height=50, width=50)

which(prop_jacc < 0.5,arr.ind=T)

# Number of clusters
library(factoextra)
library(NbClust)
m.prop_jacc=base::as.matrix(stats::as.dist(prop_jacc))
brk.minor=seq(5,245,by=5)
brk.major=seq(50,250,by=25)

# Elbow method
fig.1a=fviz_nbclust(m.prop_jacc, method = "wss",
                    FUNcluster = kmeans, k.max=250, nstart = 100, nboot=200) +
  geom_vline(xintercept=brk.minor, linetype=3,size=0.5) +
  geom_vline(xintercept=brk.major, linetype=2,size=0.5) +
  labs(subtitle = "Elbow method") 

# Silhouette method
fig.1b=fviz_nbclust(m.prop_jacc, method = "silhouette",
                   FUNcluster = kmeans, k.max=250, nstart = 100, nboot=200) +
  labs(subtitle = "Silhouette method")

# Gap statistic
set.seed(42)
fig.1c=fviz_nbclust(m.prop_jacc, method = "gap_stat", 
                    FUNcluster=kmeans, k.max=250, nstart = 100, nboot = 200 ) + 
  labs(subtitle = "Gap statistic method")

nbclust_out <- NbClust(
  data = m.prop_jacc, 
  distance = "binary", 
  min.nc = 2, # minimum number of clusters
  max.nc = 250, # maximum number of clusters
  method = "ward.D2"
)

# create a dataframe of the optimal number of clusters
nbclust_plot <- data.frame(clusters = nbclust_out$Best.nc[1, ])
# select only indices which select between 2 and 5 clusters
nbclust_plot <- subset(nbclust_plot, clusters >= 2 & clusters <= 5)

# create plot
ggplot(nbclust_plot) +
  aes(x = clusters) +
  geom_histogram(bins = 30L, fill = "#0c4c8a") +
  labs(x = "Number of clusters", y = "Frequency among all indices", title = "Optimal number of clusters") +
  theme_minimal()
res<-NbClust(prop_jacc, diss=NULL, distance = "binary", min.nc=2, max.nc=500,              method = "ward.D2", index = "kl") 
res$All.index
res$Best.nc
head(res$Best.partition)
table(res$Best.partition)

```


## Residual evolutionary rate
```{r ER}

library(ggplot2)
library(ggthemes)
# Show the fit and the residuals of expression-evolutionary rate
prop_name = grep("essential",colnames(PROP),v=T)
prop_sub = fit.ER %>% filter(!!sym(prop_name))
MR = ggplot(fit.ER, aes(y = EVO.FULL, x = PPM)) +
     geom_abline(slope=0,intercept = mean(fit.ER$EVO.FULL),size=1)+
     geom_point(fill='lightgray',shape=19,alpha=0.3) +
     geom_segment(aes(xend = PPM, yend = .fitted), col='gray',linetype='12',size=0.5) +
     # Overlay the protein sharing a particular properties
     geom_point(data=prop_sub,color='purple',fill=NA,shape=21,size=2)+
     geom_line(mapping=aes(y=.fitted),size=1) +
     xlab('Protein abundance (log10 ppm)') + ylab('Mean ER (full seq.)') +theme_clean() 
MR

# Show residuals of a particular categories 
MR2= ggplot(data=fit.ER, aes(y=.resid,x=PPM)) +
  geom_point(col='lightgray',fill='black',size=2,shape=19) +
  geom_segment(aes(xend = PPM, yend = 0),col='gray',linetype='12',size=0.5) +
  geom_abline(slope=0,intercept = 0,size=1)+
  geom_point(data=prop_sub,color='purple',fill=NA,shape=21,size=2)+
  geom_segment(data=prop_sub,aes(xend = PPM, y=0, yend = .resid),col='purple') +
  xlab('Protein abundance (log10 ppm)') + ylab('Residuals (ER)') +theme_clean() 
MR2


# Show most over/under estimated categories
ER.residuals = fit.ER %>% 
  pivot_longer( cols= starts_with('cat_'), 
                names_to = c('categories','source','property'), 
                names_pattern="cat_(.+)\\.(.+)\\.(.+)",
                values_to = "has_prop") %>%
  filter(has_prop) %>%
  relocate(SGD,GNAME,PNAME,UNIPROT,ORF,categories,source,property,has_prop) %>%
  arrange(categories,source,property,ORF) %>%
  mutate( total.resid = sum(abs(.resid)) ) %>%
  group_by(categories,source, property) %>% 
  summarise(  N=n(),
              N.neg  = sum(.resid<0), 
              N.pos  = sum(.resid>0),
              dN     = N.pos-N.neg,
              rN = N.pos/N.neg,
              SR = sum(.resid),
              SR.log = sign(SR) * log(abs(SR)),
              SR.neg = sum(.resid[.resid<0]), 
              SR.pos = sum(.resid[.resid>0]),
              SR.avg = mean_(.resid), 
           ) %>% 
    distinct() %>% 
  arrange(desc(SR.avg)) 
library(ggplot2)
library(ggfittext)
fig.0 = ggplot(ER.residuals, 
               aes(y = reorder(str_trunc(property,w=50), -SR.log),
                   x = SR.log, fill=source)) +
      geom_bar(stat='identity',position='dodge') + 
      theme_clean() +
      theme( axis.text = element_text(size=3), 
             line = element_line(size=0.1),
             rect = element_rect(size=0.1))
ggsave(fig.0, path='output/', 
       file='barplot-protein-properties-ALL.pdf',
       scale=5,limitsize = F)

fig.1 = fig.0 + 
        facet_wrap(~categories,scales = 'free_y') +
        theme( axis.text = element_text(size=4), 
             line = element_line(size=0.2),
             rect = element_rect(size=0.2))

ggsave(fig.1, 
       path='output/', file='barplot-protein-properties-CATEGORIES.pdf',
       scale=4,limitsize = F)


```
