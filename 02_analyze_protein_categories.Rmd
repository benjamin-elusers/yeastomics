---
title: "Analyze Protein Categories"
subtitle: ""
author: "[Benjamin Dubreuil](https://github.com/benjamin-elusers/)"
home: "https://github.com/benjamin-elusers/yeastomics/"
github: "benjamin-elusers"
mail: "benjamin.dubreuil@weizmann.ac.il"
date: "`r format(Sys.time(), 'Last Modified: %d-%b-%Y %R %p')`"
output:
  rmdformats::downcute:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: tango
#  html_document: 
    code_download: true
    code_folding: hide
    fig_caption: yes
    keep_md: yes
#    toc: yes
    toc_depth: 3
    toc_float:
      toc_collapsed: true
    number_sections: true
    theme: lumen
  editor_options: 
    chunk_output_type: console
  bibliography: bibliography.bib
  csl: biomed-central.csl
---
<!-- Github Logo -->
<a href="https://github.com/benjamin-elusers/yeastomics/" class="github-corner" aria-label="View source on Github">
  <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#69b3a2; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
  </svg>
</a>

<style> 
.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}
@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}
@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      collapse = TRUE,
                      cache.lazy = FALSE,
                      autodep = TRUE,
                      warning = FALSE)
#if('utils' %in% search()){ detach('utils') }
#utils = attach(NULL,name = 'utils')
#if('funcs' %in% search()){ detach('funcs') }
#funcs = attach(NULL,name = 'funcs')

suppressPackageStartupMessages({
  library(tictoc)
  library(tidyverse)
  library(stringr)
  library(hablar)
  
  
  source("src/utils.r")
  source("src/function_annotation.r")
  source("src/function_sequence.r")
  source("src/function_phylogenetic.r")
  source("src/function_analysis.r")
  source("src/function_datalocal.r")
  source("src/function_datapub.r")
})

# turn off annoying messages from dplyr::summarise
options(dplyr.summarise.inform = FALSE, dplyr.width=Inf)
```

# Evolutionary dataset

```{r evodata}
# EVOLUTIONARY RATE
FUNGI = load.dubreuil2021.data(1) %>% 
     as_tibble() %>%
     dplyr::select(c(starts_with('EVO.'),'PPM','ORF','UNIPROT')) %>%
     hablar::convert(dbl(EVO.FULL), dbl(PPM)) %>% 
     ungroup()
STRAINS = readRDS("data/rate4site-1011-strains.rds") %>% 
       dplyr::filter( !is.na(ID) ) %>% 
       group_by(orf,len.s288c) %>%
       summarise(r4s.strains = mean_(SCORE),
                 max_r4s.strains = max_(SCORE)
       ) %>% left_join(PROTEOME, "ORF")

R4S = left_join(STRAINS,FUNGI, by=c('orf'='ORF')) %>%
      mutate( log10.r4s.fungi = log10(EVO.FULL),
              log10.r4s.strains=log10(r4s.strains))

# Fitting mean Evolutionary rate (R) to Protein abundance (E)
init.params =  list(Asym = 3, xmid = 1.5, scal=-1)
nls.fit = nls(EVO.FULL ~ SSlogis(PPM,Asym,xmid,scal),start=init.params,data = ER )
fit.ER = broom::augment_columns(x = nls.fit, data = ER) %>% 
         mutate(SSR = sum(.resid^2), SR = sum(.resid) )

```

# Protein categories

## Loading precomputed data

```{r protcat}
# protein properties (qualitative)
PROP=readRDS(get.last.file("output","proteome-properties"))
# protein features (quantitative)
FEAT = readRDS(get.last.file("output","proteome-features"))

# ER fit with properties and features
ER.PROP = fit.ER %>% left_join(PROP,by=c('UNIPROT'='UNIPROTKB','ORF'='ORF'))
dim(ER.PROP)
ER.FEAT = fit.ER %>% left_join(FEAT,by=c('UNIPROT'='UNIPROTKB','ORF'='ORF'))
dim(ER.FEAT)
colnames(FEAT)
# Matrix format of properties and features
PROP.m = PROP %>% 
      ungroup() %>% 
      dplyr::select( where(is.logical) )  %>% 
      convert(num(everything())) %>%
      as.matrix


FEAT.m = FEAT %>%
        ungroup() %>% 
        dplyr::select( where(is.numeric) ) %>%
      as.matrix

TOT_PROP=ncol(PROP.m)
TOT_FEAT=ncol(FEAT.m)

```


There are a total of **`r TOT_PROP`** proteome properties and **`r TOT_FEAT`**
We also gathered **`r TOTAL_FEATURES`** protein features.

## Compute properties similarities

To compare properties, we will use the Jaccard distance on the binary matrix where rows are proteins and columns are the properties. The distance corresponds to the proportion of (TRUE, TRUE) pairs, but not considering (FALSE, FALSE) pairs.

So it compares the intersection with the union of protein sets between properties.


```{r properties-similarity}
# Pearson correlation between properties
PROP_cor = preload("output/properties-correlation.rds",
                   coop::pcor(PROP.m), 
                   doing="Computing Pearson correlation between properties...")
# Jaccard distance between properties
PROP_jacc = preload("output/properties-jaccard.rds", 
                   proxy::dist(PROP.m, PROP.m, by_rows=F, method="Jaccard"),
                   doing="Computing Jaccard distance between properties...") 

FEAT_scor = preload("output/features-spearman.rds",
                   cor(FEAT.m,use='pairwise.complete.obs',method = 'spearman'), 
                   doing="Computing Spearman correlation between features...")

prop = PROP %>% 
        pivot_longer(cols = starts_with('cat_'),
                     names_to = c('categories','source','property'), 
                     names_pattern="cat_(.+)\\.(.+)\\.(.+)",
                     values_to = "has_prop") %>%
        mutate(has_ortho = ORF %in% ER$ORF,
               col_prop = paste0(categories,'.',source,'.',property))

prop.size = prop %>% 
  group_by(categories,source,property) %>% 
  summarise( in_prot=sum(has_prop), 
             in_ortho=sum(has_prop*has_ortho),
             r_prot_ortho = in_ortho/in_prot)
```
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> a08cec7eb6a21181fb3779265fc25ea862a25336

```{r F0 non-conserved properties}
library(cowplot)
theme_set(theme_cowplot())

<<<<<<< HEAD
=======

```{r F0 non-conserved properties}
library(cowplot)
theme_set(theme_cowplot())

>>>>>>> a08cec7eb6a21181fb3779265fc25ea862a25336
=======
>>>>>>> a08cec7eb6a21181fb3779265fc25ea862a25336
data.to.f0 = prop.size %>% filter(in_ortho<10)
# 1. Properties under-represented in yeast orthologs
f0 = ggplot(data.to.f0 ) + 
  geom_bar(aes(y=in_prot, x=reorder(property,in_prot),fill=source),stat='identity') +
  geom_bar(aes(y=in_ortho, x=reorder(property,in_prot)),stat='identity') + 
  geom_hline(yintercept=10,color='black',linetype='dashed') +
  facet_wrap(~categories,scales = 'free_y',ncol=1) +
  coord_flip() + theme( axis.text = element_text(size=6))
save_plot(path="output/", filename = 'F0.properties-absent-ortho.pdf', plot = f0, device = 'pdf', scale = 3 )
save_plot(path="output/", filename = 'F0.properties-absent-ortho.png', plot = f0, device = 'png', scale = 2 )

categories=unique(data.to.f0$categories)
for( icat in seq_along(categories) ){
  CAT = categories[icat]
  f0.1 = ggplot(data.to.f0 %>% filter(categories == CAT )) + 
    geom_bar(aes(y=in_prot, x=reorder(property,in_prot),fill=source),stat='identity') +
    geom_bar(aes(y=in_ortho, x=reorder(property,in_prot)),stat='identity') + 
    geom_hline(yintercept=10,color='black',linetype='dashed') +
    facet_wrap(~categories,scales = 'free_y',ncol=2) +
    coord_flip() + theme( axis.text = element_text(size=8)) +
    scale_x_discrete(position = "top", name='') + ylim(0,100)
  save_plot(path="output/", filename = sprintf('F0.%s.properties-absent-ortho-%s.png',icat,CAT), plot = f0.1,device = 'png', scale = 2 )
  save_plot(path="output/", filename = sprintf('F0.%s.properties-absent-ortho-%s.pdf',icat,CAT), plot = f0.1,device = 'pdf', scale = 2 )
}
```

```{r F1 yeast QR properties }
n_distinct(prop$GNAME)/n_distinct(prop$property)
prop %>% filter(has_ortho) %>% ungroup() %>% summarise(np=n_distinct(property), ng=n_distinct(GNAME), r=ng/np)
prop %>% ungroup() %>% summarise(np=n_distinct(property), ng=n_distinct(GNAME), r=ng/np)

data.to.f1  = prop %>% mutate(propinfo = factor(has_prop+2*has_ortho, levels = c(0,1,2,3), labels('none','nocons_prop','cons_prot','cons_prop')))
f1.1 = ggplot(data.to.f1) +
  geom_raster(aes(x=GNAME,y=property,fill=propinfo),show.legend = F) +
  scale_fill_manual(values=c('white','black')) +
  scale_fill_manual(values=c('none'='white','nocons_prop'='red','cons_prot'='gray','cons_prop'='black'),na.value='white') +
  theme(legend.title = element_blank(), axis.text = element_blank())
f1.2 = ggplot(data.to.f1 %>% filter(has_ortho)) +
  geom_raster(aes(x=GNAME,y=property,fill=has_prop),show.legend = F,interpolate=T) +
  scale_fill_manual(values=c('white','black')) +
  theme(legend.title = element_blank(), axis.text = element_blank())
f1 = plot_grid(f1.1,f1.2)
save_plot(path="output/", filename = 'F1.properties-proteome.png', plot = f1,device = 'png', base_height = 13,base_width=26)
save_plot(path="output/", filename = 'F1.properties-proteome.pdf', plot = f1,device = 'pdf', base_height = 13,base_width=26)
# pheatmap::pheatmap(prop[,-1]*1, 
#                    show_rownames = T,show_colnames = F,
#                    cluster_rows = T, cluster_cols = F, 
#                    cellwidth = 25, cellheight = 5,
#                    border_color = NA, color = c('black','white'), 
#                    filename='output/heatmap-protein-binary-properties.pdf'
#                    )

#library(proxy)
# Example of Jaccard distance on binary data
# x <- matrix(sample(c(FALSE, TRUE), 50, rep = TRUE), ncol = 10)
# dist(x, x, method = "Jaccard") # cross distances


# hc = hclust(d=stats::as.dist(prop_jacc),method = 'ward.D2')
# grp = cutree(hc,k=100) 

# pheatmap::pheatmap(prop_jacc,
#                    show_colnames = F, show_rownames = T,
#                    cluster_cols = hc, cluster_rows = hc,
#                    clustering_distance_rows = prop_jacc,
#                    clustering_distance_cols = prop_jacc,
#                    cutree_rows = 100,cutree_cols = 100,
#                    fontsize=3, border_color = NA, silent=T, 
#                    cellheight=3, cellwidth=3,
#                    filename="output/properties-jaccard.pdf", height=50, width=50)
# which(prop_jacc < 0.5,arr.ind=T)
# # Number of clusters
# library(factoextra)
# library(NbClust)
# m.prop_jacc=base::as.matrix(stats::as.dist(prop_jacc))
# 
# caret::findCorrelation
# 
# brk.minor=seq(5,45,by=5)
# brk.major=seq(50,50,by=25)
# 
# # Elbow method
# fig.1a=fviz_nbclust(m.prop_jacc, method = "wss",
#                     FUNcluster = kmeans, k.max=50, nstart = 50, nboot=100) +
#   geom_vline(xintercept=brk.minor, linetype=3,size=0.5) +
#   geom_vline(xintercept=brk.major, linetype=2,size=0.5) +
#   labs(subtitle = "Elbow method") 
# 
# # Silhouette method
# fig.1b=fviz_nbclust(m.prop_jacc, method = "silhouette",
#                    FUNcluster = kmeans, k.max=50, nstart = 50, nboot=100) +
#   labs(subtitle = "Silhouette method")
# 
# # Gap statistic
# set.seed(42)
# fig.1c=fviz_nbclust(m.prop_jacc, method = "gap_stat", 
#                     FUNcluster=kmeans, k.max=50, nstart = 50, nboot = 100 ) + 
#   labs(subtitle = "Gap statistic method")
# 
# nbclust_out <- NbClust(
#   data = PROP_lgl,
#   diss = NULL,
#   distance = 'binary', 
#   min.nc = 2, # minimum number of clusters
#   max.nc = 50, # maximum number of clusters
#   method = "complete"
# )

# ensure the results are repeatable
# set.seed(7)
# # load the library
# library(mlbench)
# library(caret)
# print(prop_cor)
# hicor <- findCorrelation(prop_cor, cutoff=0.5)
# 
# 
# control <- rfeControl(functions=rfFuncs, method="cv", number=10)
# # run the RFE algorithm
# results <- rfe(ER.PROP[,19:935], ER.PROP$EVO.FULL , sizes=c(1:917), rfeControl=control)
# # summarize the results
# print(results)
# # list the chosen features
# predictors(results)
# # plot the results
# plot(results, type=c("g", "o"))
# 

# library(Boruta)
# train.data = ER.PROP %>% dplyr::select(EVO.FULL, starts_with('cat_'))
# boruta_output <- Boruta(EVO.FULL ~ ., data=na.omit(train.data), doTrace=0)  
# boruta_signif <- getSelectedAttributes(boruta_output, withTentative = TRUE)
# print(boruta_signif)  
# roughFixMod <- TentativeRoughFix(boruta_output)
# boruta_signif <- getSelectedAttributes(roughFixMod)
# print(boruta_signif)
# imps <- attStats(roughFixMod)
# imps2 = imps[imps$decision != 'Rejected', c('meanImp', 'decision')]
# plot(boruta_output, cex.axis=.7, las=2, xlab="", main="Variable Importance")  

#head(imps2[order(-imps2$meanImp), ])  # descending sort
```


## Residual evolutionary rate
```{r ER}

library(ggplot2)
library(ggthemes)
library(cowplot)
# Show the fit and the residuals of expression-evolutionary rate
prop_name = grep("essential_core",colnames(PROP),v=T)
prop_sub = ER.PROP %>% filter(!!sym(prop_name))
MR = ggplot(fit.ER, aes(y = EVO.FULL, x = PPM)) +
     geom_abline(slope=0,intercept = mean(fit.ER$EVO.FULL),size=1)+
     geom_point(fill='lightgray',shape=19,alpha=0.3) +
     geom_segment(aes(xend = PPM, yend = .fitted), col='gray',linetype='12',size=0.5) +
     # Overlay the protein sharing a particular properties
     geom_point(data=prop_sub,color='purple',fill=NA,shape=21,size=2)+
     geom_line(mapping=aes(y=.fitted),size=1) +
     xlab('Protein abundance (log10 ppm)') + ylab('Mean ER (full seq.)')
MR

# Show residuals of a particular categories 
MR2= ggplot(data=fit.ER, aes(y=.resid,x=PPM)) +
  geom_point(col='lightgray',fill='black',size=2,shape=19) +
  geom_segment(aes(xend = PPM, yend = 0),col='gray',linetype='12',size=0.5) +
  geom_abline(slope=0,intercept = 0,size=1)+
  geom_point(data=prop_sub,color='purple',fill=NA,shape=21,size=2)+
  geom_segment(data=prop_sub,aes(xend = PPM, y=0, yend = .resid),col='purple') +
  xlab('Protein abundance (log10 ppm)') + ylab('Residuals (ER)') 
  
MR2
```

```{r rank-properties}
# Show most over/under estimated categories
ER.residuals = ER.PROP %>% 
  pivot_longer( cols= starts_with('cat_'), 
                names_to = c('categories','source','property'), 
                names_pattern="cat_(.+)\\.(.+)\\.(.+)",
                values_to = "has_prop") %>%
  filter(has_prop) %>%
  relocate(SGD,GNAME,PNAME,UNIPROT,ORF,categories,source,property,has_prop) %>%
  arrange(categories,source,property,ORF) %>%
  mutate( total.resid = sum(abs(.resid)) ) %>%
  group_by(categories,source, property) %>% 
  summarise(  N=n(),
              N.neg  = sum(.resid<0), 
              N.pos  = sum(.resid>0),
              dN     = N.pos-N.neg,
              rN = N.pos/N.neg,
              SR = sum(.resid),
              SR.log = sign(SR) * log(abs(SR)),
              SR.neg = sum(.resid[.resid<0]), 
              SR.pos = sum(.resid[.resid>0]),
              SR.avg = mean_(.resid), 
           ) %>% 
    distinct() %>% 
  arrange(desc(SR.avg)) %>%
  group_by(categories) %>% mutate(rSR = dense_rank(SR) , ncat=n())
library(ggplot2)
library(ggfittext)
fig.0 = ggplot(ER.residuals, 
               aes(y = reorder(str_trunc(property,w=50), -SR.log),
                   x = SR.log, fill=source)) +
      geom_bar(stat='identity',position='dodge') + 
      theme( axis.text = element_text(size=3))
fig.0
ggsave(fig.0, path='output/', 
       file='barplot-protein-properties-ALL.pdf',
       scale=5,limitsize = F)

fig.1 = ggplot(ER.residuals %>% filter(rSR < 10 | rSR > ncat-10), 
               aes(y = reorder(str_trunc(property,w=50), -SR.log),
                   x = SR.log, fill=source)) +
      geom_bar(stat='identity',position='dodge')  + 
        facet_wrap(~categories,scales = 'free_y') +
        theme( axis.text = element_text(size=8))
fig.1
ggsave(fig.1, 
       path='output/', file='barplot-protein-properties-CATEGORIES-top10.pdf',
       scale=2,limitsize = F)
```

```{r rank-features}
ER.residuals.cor=ER.FEAT %>% 
  pivot_longer(cols = starts_with('cat_'),
               names_to = c('categories','source','feature'), 
               names_pattern="cat_(.+)\\.(.+)\\.(.+)",
              values_to = "value") %>%
  group_by(feature) %>% mutate( nval = sum(!is.na(value)), 
                                R2=ifelse(nval>0,scor(.resid,value)$estimate^2*nval,NA)) %>%
  group_by(categories) %>% mutate( ncat=n(), rR2=dense_rank(R2)) %>% 
  summarise(categories,source,feature,nval,R2,rR2,ncat)
fig.2 = ggplot(ER.residuals.cor , 
               aes(y = reorder(str_trunc(feature,w=50), -R2),
                   x = log(R2), fill=source)) +
      geom_bar(stat='identity',position='dodge')  + 
        facet_wrap(~categories,scales = 'free_y') +
        theme( axis.text = element_text(size=8))
fig.2
ggsave(fig.2, 
       path='output/', file='barplot-protein-features_vs_ERresiduals-CATEGORIES.pdf',
       scale=2.5,limitsize = F)

```
